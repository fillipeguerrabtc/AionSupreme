#!/usr/bin/env tsx
/**
 * PHASE 1.2: Generate Shared Translation Registry
 * 
 * Creates type-safe translation registry from string inventory:
 * 1. Filters UI-relevant strings (ui, error, validation categories)
 * 2. Generates TypeScript types for translation keys
 * 3. Creates PT-BR/EN-US/ES-ES locale files with structure
 * 4. Exports type-safe translation function
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import path from 'path';

interface StringOccurrence {
  value: string;
  category: string;
  suggestedKey: string;
  file: string;
  line: number;
}

interface InventoryResult {
  occurrences: StringOccurrence[];
}

interface TranslationEntry {
  key: string;
  ptBR: string;
  enUS: string;
  esES: string;
  category: string;
  source: string;
}

// Only translate UI-relevant categories
const RELEVANT_CATEGORIES = ['ui', 'error', 'validation'];

function shouldIncludeString(occ: StringOccurrence): boolean {
  // Filter by category
  if (!RELEVANT_CATEGORIES.includes(occ.category)) {
    return false;
  }
  
  // Skip very short strings (likely not UI text)
  if (occ.value.length < 3) {
    return false;
  }
  
  // Skip placeholder patterns from emergency cleanup
  if (occ.value === '[PT]' || occ.value === '[TEXTO]') {
    return false;
  }
  
  return true;
}

function normalizeKey(key: string): string {
  return key
    .toLowerCase()
    .replace(/[^a-z0-9.]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
}

function generateTranslations(value: string): { ptBR: string; enUS: string; esES: string } {
  // For now, use the original value as PT-BR
  // EN and ES would need manual translation or AI translation service
  return {
    ptBR: value,
    enUS: value,  // TODO: Translate
    esES: value,  // TODO: Translate
  };
}

function buildNestedObject(entries: TranslationEntry[]): any {
  const result: any = {};
  
  for (const entry of entries) {
    const parts = entry.key.split('.');
    let current = result;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    
    const lastPart = parts[parts.length - 1];
    current[lastPart] = entry.ptBR;
  }
  
  return result;
}

function generateTypeDefinition(entries: TranslationEntry[], nestObj: any): string {
  // Build deep type definition from nested object structure
  // This avoids TS union limits and provides proper type safety
  
  function buildTypeFromObj(obj: any, indent: string = '  '): string {
    const lines: string[] = [];
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        lines.push(`${indent}${key}: string;`);
      } else if (typeof value === 'object') {
        lines.push(`${indent}${key}: {`);
        lines.push(buildTypeFromObj(value, indent + '  '));
        lines.push(`${indent}};`);
      }
    }
    return lines.join('\n');
  }
  
  return `/**
 * Auto-generated translation types
 * DO NOT EDIT MANUALLY - Generated by generate-translation-registry.ts
 * 
 * Type-safe translations for ${entries.length} keys
 */

export type Locale = 'pt-BR' | 'en-US' | 'es-ES';

export interface Translations {
${buildTypeFromObj(nestObj)}
}

// Helper type to extract all valid translation keys (for validation)
export type TranslationPath = ExtractPaths<Translations>;

type ExtractPaths<T, Prefix extends string = ''> = {
  [K in keyof T]: T[K] extends string
    ? \`\${Prefix}\${string & K}\`
    : T[K] extends object
    ? ExtractPaths<T[K], \`\${Prefix}\${string & K}.\`>
    : never;
}[keyof T];
`;
}

async function main() {
  console.log('ðŸ”§ Generating translation registry...\n');
  
  // Load inventory
  const inventoryPath = 'scripts/i18n/string-inventory.json';
  const inventory: InventoryResult = JSON.parse(readFileSync(inventoryPath, 'utf-8'));
  
  console.log(`ðŸ“Š Loaded ${inventory.occurrences.length} total strings`);
  
  // Filter relevant strings
  const relevant = inventory.occurrences.filter(shouldIncludeString);
  console.log(`âœ… Filtered to ${relevant.length} UI-relevant strings\n`);
  
  // Group by suggested key to deduplicate
  const keyMap = new Map<string, StringOccurrence>();
  for (const occ of relevant) {
    const normalizedKey = normalizeKey(occ.suggestedKey);
    if (!keyMap.has(normalizedKey)) {
      keyMap.set(normalizedKey, occ);
    }
  }
  
  console.log(`ðŸ”‘ Deduplicated to ${keyMap.size} unique keys\n`);
  
  // Generate translation entries
  const entries: TranslationEntry[] = [];
  for (const [key, occ] of keyMap) {
    const translations = generateTranslations(occ.value);
    entries.push({
      key,
      ...translations,
      category: occ.category,
      source: `${path.basename(occ.file)}:${occ.line}`,
    });
  }
  
  // Sort by key for consistency
  entries.sort((a, b) => a.key.localeCompare(b.key));
  
  // Generate outputs
  console.log('ðŸ“ Generating files...\n');
  
  // Build nested objects first (needed for types)
  const ptBRObj = buildNestedObject(entries.map(e => ({ ...e, ptBR: e.ptBR })));
  const enUSObj = buildNestedObject(entries.map(e => ({ ...e, ptBR: e.enUS })));
  const esESObj = buildNestedObject(entries.map(e => ({ ...e, ptBR: e.esES })));
  
  // 1. Type definitions (using nested structure)
  const typesContent = generateTypeDefinition(entries, ptBRObj);
  const typesPath = 'shared/i18n-types.ts';
  writeFileSync(typesPath, typesContent);
  console.log(`âœ… Types: ${typesPath} (${entries.length} keys with FULL type coverage)`);
  
  // 2. PT-BR locale (primary) - already built above
  const ptBRPath = 'client/src/locales/pt-BR.json';
  mkdirSync(path.dirname(ptBRPath), { recursive: true });
  writeFileSync(ptBRPath, JSON.stringify(ptBRObj, null, 2));
  console.log(`âœ… PT-BR: ${ptBRPath}`);
  
  // 3. EN-US locale (TODO: translate) - already built above
  const enUSPath = 'client/src/locales/en-US.json';
  writeFileSync(enUSPath, JSON.stringify(enUSObj, null, 2));
  console.log(`âœ… EN-US: ${enUSPath} (needs translation)`);
  
  // 4. ES-ES locale (TODO: translate) - already built above
  const esESPath = 'client/src/locales/es-ES.json';
  writeFileSync(esESPath, JSON.stringify(esESObj, null, 2));
  console.log(`âœ… ES-ES: ${esESPath} (needs translation)`);
  
  // 5. Translation registry manifest
  const manifestPath = 'scripts/i18n/translation-registry.json';
  writeFileSync(manifestPath, JSON.stringify({
    generated: new Date().toISOString(),
    totalKeys: entries.length,
    byCategory: entries.reduce((acc, e) => {
      acc[e.category] = (acc[e.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    entries,
  }, null, 2));
  console.log(`âœ… Manifest: ${manifestPath}`);
  
  // Summary
  console.log(`\nðŸ“Š SUMMARY`);
  console.log('='.repeat(60));
  console.log(`Total Keys: ${entries.length}`);
  console.log(`\nBy Category:`);
  const byCategory = entries.reduce((acc, e) => {
    acc[e.category] = (acc[e.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  Object.entries(byCategory).forEach(([cat, count]) => {
    console.log(`  ${cat.padEnd(12)}: ${count}`);
  });
  
  console.log(`\nâœ… Translation registry generated!`);
  console.log(`ðŸŽ¯ Next: Phase 1.3 - Create codemod to transform strings\n`);
}

main();
