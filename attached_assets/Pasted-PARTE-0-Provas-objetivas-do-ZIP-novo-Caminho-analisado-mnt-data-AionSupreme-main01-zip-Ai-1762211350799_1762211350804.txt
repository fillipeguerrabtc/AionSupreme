PARTE 0 — Provas objetivas (do ZIP novo)

Caminho analisado: /mnt/data/AionSupreme-main01.zip → AionSupreme-main/

Arquivos totais: 302

Linhas inspecionadas (texto): 97.348

Documentos .md: 18 (todos lidos)

README.md, design_guidelines.md, replit.md, deployment/README.md,
docs/API.md, docs/ARCHITECTURE.md, docs/AUTOMATIC_FALLBACK.md, docs/COLAB_KEEPALIVE_GUIDE.md,
docs/DEDUPLICATION_ABSORPTION_GUIDE.md, docs/FREE_GPU_API_STRATEGY.md, docs/GPU_WORKERS_SETUP_GUIDE.md,
docs/GUIA_DESENVOLVEDOR.md, docs/GUIA_PASSO_A_PASSO_GOOGLE_COLAB.md, docs/GUIA_PRODUTO.md,
docs/NAMESPACE_CLASSIFICATION_GUIDE.md, notebooks/COLAB_KEEP_ALIVE_FIX.md, notebooks/COLAB_TIMEZONE_FIX.md, scripts/README.md

Hotspots medidos (contagens no código):

console.*: 1.462 ocorrências

any: 715

process.env.VAR: 102

innerHTML/dangerouslySetInnerHTML: 4 (precisa sanitizar)

eval/Function(: 3

EventSource/text/event-stream (SSE): muitos refs, mas ChatPage não usa streaming

Top offenders (exemplos)

server/routes.ts — 4801 linhas, 102 console, 154 any, 6 process.env, 1 TODO

server/model/free-llm-providers.ts — usa OPEN_ROUTER_API_KEY (forma inconsistente)

server/index.ts — não aplica helmet/cors; não aplica middleware de auditoria

server/rag/vector-store.ts — FAISS em memória, sem persistência (perde index no restart)

client/src/pages/chat/ChatPage.tsx — não usa SSE token-a-token

client/src/components/IconPicker.tsx, client/src/components/agents/NamespaceIconDisplay.tsx, client/src/components/ui/chart.tsx, client/src/pages/admin/NamespacesPage.tsx — usam HTML bruto → sanitizar

Isso é do repositório novo. Vamos aos consertos.

PARTE 1 — Sumário executivo

Está muito bom

Arquitetura local-first + fallback fiel ao que definimos (KB/RAG → GPU pool → Free APIs → OpenAI último recurso).

Curadoria (HITL) existe e encaminha para promoção à KB.

Namespaces + multi-agentes ativos no admin.

Orquestrador GPU gratuito e tracking de tokens/custo presentes.

Política default UNRESTRICTED (como você quer) via pipeline.

Gaps críticos (corrigir agora)

Logs verbosos (1.462) e any (715) — ruído, risco e bugs mascarados.

ENV inconsistente (OPEN_ROUTER_API_KEY vs OPENROUTER_API_KEY) — falhas intermitentes.

Hardening HTTP ausente — falta helmet/cors.

Vector store sem persistência — perde índice no restart.

GPU orchestrator sem circuit-breaker/backoff — tempestade de retries.

SSE no chat — faltando (UX/latência).

Sanity check de ambiente — inexistente (subidas “meia-boca”).

Audit trail — middleware existe, não aplicado; falta endpoint/painel.

Docker como root — endurecer.

PARTE 2 — Patches prontos (copiar e colar)

Todos com caminhos reais do seu repo novo.

2.1 Fail-fast do ambiente

server/scripts/check-env.ts (novo)

const REQUIRED = [
  "DATABASE_URL",
  "SESSION_SECRET",
  // Exigir ao menos 1 provedor de fallback? Descomente ao usar:
  // "OPENAI_API_KEY", "OPENROUTER_API_KEY", "GROQ_API_KEY", "GOOGLE_API_KEY", "HF_API_KEY",
];

const missing = REQUIRED.filter(k => !process.env[k]);
if (missing.length) {
  console.error("❌ Missing required env:", missing.join(", "));
  process.exit(1);
}
console.log("✅ Env check OK");


server/index.ts (no topo)

import "./scripts/check-env";

2.2 Hardening HTTP (CORS + Helmet)

server/middleware/security.ts (novo)

import type { Express } from "express";
import cors from "cors";
import helmet from "helmet";

export function applySecurity(app: Express) {
  app.use(helmet({
    crossOriginResourcePolicy: { policy: "cross-origin" },
    contentSecurityPolicy: false, // ajuste CSP se usar iframes/embeds
  }));
  app.use(cors({
    origin: process.env.CORS_ORIGIN?.split(",") || "*",
    credentials: true,
    methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"]
  }));
}


server/index.ts

import { applySecurity } from "./middleware/security";
...
const app = express();
applySecurity(app);

2.3 Logger com requestId + níveis (p/ substituir console.*)

server/utils/logger.ts (novo)

import pino from "pino";
import { randomUUID } from "crypto";
import type { Request, Response, NextFunction } from "express";

export const log = pino({ level: process.env.LOG_LEVEL || "info" });

export function withRequestId(req: Request, _res: Response, next: NextFunction) {
  (req as any).requestId = (req.headers["x-request-id"] as string) || randomUUID();
  next();
}

export function reqLog(req: Request) {
  return log.child({ rid: (req as any).requestId, path: req.path, method: req.method });
}


server/index.ts

import { withRequestId } from "./utils/logger";
app.use(withRequestId);


Depois, nas rotas críticas: troque console.* por reqLog(req).info/warn/error(...).

2.4 Free APIs — ENV padronizada + logs redigidos

server/model/free-llm-providers.ts (ajuste nas chaves)

const env = (name: string, aliases: string[] = []) =>
  process.env[name] || aliases.map(a => process.env[a]).find(Boolean) || "";

const OPENROUTER_API_KEY = env("OPENROUTER_API_KEY", ["OPEN_ROUTER_API_KEY"]);
const GROQ_API_KEY       = env("GROQ_API_KEY");
const GOOGLE_API_KEY     = env("GOOGLE_API_KEY", ["GEMINI_API_KEY"]);
const HF_API_KEY         = env("HF_API_KEY", ["HUGGINGFACE_API_KEY"]);

// não logar valores, só presença:
const present = (s: string) => (s ? "yes" : "no");
console.log(`[Free LLM] providers: openrouter=${present(OPENROUTER_API_KEY)} groq=${present(GROQ_API_KEY)} gemini=${present(GOOGLE_API_KEY)} hf=${present(HF_API_KEY)}`);


Ação: padronize seus workflows/Secrets para OPENROUTER_API_KEY.

2.5 GPU Orchestrator — circuit-breaker + backoff

server/model/gpu-orchestrator.ts (acréscimo)

type State = { fails: number; openedAt?: number };
const states = new Map<string, State>();
const OPEN_AFTER = 3;
const COOLDOWN_MS = 60_000;

function isOpen(url: string) {
  const s = states.get(url); if (!s?.openedAt) return false;
  return Date.now() - s.openedAt < COOLDOWN_MS;
}

async function callWorker(url: string, payload: any) {
  if (isOpen(url)) throw new Error("circuit-open");
  try {
    const r = await fetch(`${url}/generate`, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if (!r.ok) throw new Error(`bad-status:${r.status}`);
    states.set(url, { fails: 0 });
    return await r.json();
  } catch (e) {
    const s = states.get(url) || { fails: 0 };
    s.fails += 1;
    if (s.fails >= OPEN_AFTER) s.openedAt = Date.now();
    states.set(url, s);
    throw e;
  }
}

2.6 Vector Store — persistência (snapshot)

Problema atual: server/rag/vector-store.ts só em memória.

Patch — salvar/ler snapshot:

import fs from "fs";
import path from "path";
const SNAPSHOT = process.env.VECTOR_SNAPSHOT_PATH || "./data/vectorstore.snapshot.json";

export class VectorStore {
  // ... sua implementação atual
  load(): void {
    if (!fs.existsSync(SNAPSHOT)) return;
    const raw = JSON.parse(fs.readFileSync(SNAPSHOT, "utf-8"));
    this.vectors.clear(); this.metadata.clear();
    for (const [id, v] of Object.entries(raw.vectors)) this.vectors.set(Number(id), v as number[]);
    for (const [id, m] of Object.entries(raw.metadata)) this.metadata.set(Number(id), m as any);
    console.log(`[VectorStore] Loaded snapshot (${this.vectors.size} vectors)`);
  }
  save(): void {
    fs.mkdirSync(path.dirname(SNAPSHOT), { recursive: true });
    const out = {
      vectors: Object.fromEntries(this.vectors.entries()),
      metadata: Object.fromEntries(this.metadata.entries()),
    };
    fs.writeFileSync(SNAPSHOT, JSON.stringify(out));
    console.log("[VectorStore] Snapshot saved");
  }
}


Operação:

Chamar vectorStore.load() no boot.

Chamar vectorStore.save() ao final de cada ingest/promote e no SIGTERM.

Médio prazo: migrar para pgvector/FAISS GPU.

2.7 Rebuild incremental assíncrono

server/rag/knowledge-indexer.ts (adicionar fila)

const queue: number[] = [];
let running = false;

export async function scheduleIndex(documentId: number) {
  queue.push(documentId);
  if (!running) run();
}
async function run() {
  running = true;
  while (queue.length) {
    const id = queue.shift()!;
    try {
      await ragService.indexDocument(id);
    } catch (e) {
      console.error("[Indexer] fail", id, (e as Error).message);
    }
  }
  running = false;
}


Ao aprovar na curadoria, chame scheduleIndex(docId).

2.8 SSE/Streaming no chat (backend + front)

server/routes/chat-stream.ts (novo)

import type { Express, Request, Response } from "express";
import { generateWithPriority } from "../llm/priority-orchestrator";

export function registerChatStream(app: Express) {
  app.get("/api/chat/stream", async (req: Request, res: Response) => {
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");

    const payload = JSON.parse(String(req.query.payload || "{}"));

    try {
      for await (const token of generateWithPriority.stream(payload)) {
        res.write(`data: ${JSON.stringify({ token })}\n\n`);
      }
      res.write("data: [DONE]\n\n");
    } catch (e: any) {
      res.write(`event: error\ndata: ${JSON.stringify({ message: e?.message || "stream-error" })}\n\n`);
    } finally {
      res.end();
    }
  });
}


server/routes.ts

import { registerChatStream } from "./routes/chat-stream";
...
registerChatStream(app);


client/src/pages/chat/ChatPage.tsx (adicionar streaming)

function streamAnswer(payload: any, onToken: (t:string)=>void, onDone: ()=>void, onError:(m:string)=>void){
  const es = new EventSource(`/api/chat/stream?payload=${encodeURIComponent(JSON.stringify(payload))}`);
  es.onmessage = (e) => {
    if (e.data === "[DONE]") { es.close(); onDone(); return; }
    const { token } = JSON.parse(e.data); onToken(token);
  };
  es.addEventListener("error", () => { es.close(); onError("stream-error"); });
}

2.9 Sanitização de HTML no front (XSS)

Arquivos:

client/src/components/IconPicker.tsx

client/src/components/agents/NamespaceIconDisplay.tsx

client/src/components/ui/chart.tsx

client/src/pages/admin/NamespacesPage.tsx

Patch básico:

import DOMPurify from "dompurify";
...
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(htmlString) }} />

2.10 Tipagem de erros + remoção de any nas rotas

Padrão para todos os catch:

} catch (error: unknown) {
  const msg = error instanceof Error ? error.message : "unknown-error";
  reqLog(req).error({ msg });
  return res.status(500).json({ error: msg });
}


Validação de payload com Zod (exemplo de KB promote):

import { z } from "zod";
const PromoteSchema = z.object({
  text: z.string().min(1),
  suggestedNamespaces: z.array(z.string()).min(1),
  title: z.string().optional(),
  submittedBy: z.string().optional(),
});

app.post("/kb/promote", async (req, res) => {
  const parse = PromoteSchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });
  const { text, suggestedNamespaces, title, submittedBy } = parse.data;
  ...
});

2.11 Auditoria de políticas — endpoint + painel

Há server/middleware/audit.ts, mas não está aplicado.
Aplique o middleware no boot e exponha endpoint:

server/index.ts

import { auditMiddleware } from "./middleware/audit";
app.use(auditMiddleware);


server/routes/policy-audit.ts (novo)

import type { Express } from "express";
import { db } from "../db";
import { auditLogs } from "@shared/schema";

export function registerPolicyAudit(app: Express) {
  app.get("/api/admin/policy/audit", async (_req, res) => {
    const rows = await db.select().from(auditLogs).limit(100).orderBy(auditLogs.createdAt);
    res.json(rows);
  });
}


No painel admin, crie a aba Audit Trail listando as últimas 100 alterações.

2.12 Docker sem root

Dockerfile (final)

RUN addgroup -S app && adduser -S app -G app && chown -R app:app /app
USER app

2.13 Qualidade contínua

.eslintrc.json (novo)

{
  "root": true,
  "env": { "es2022": true, "node": true, "browser": true },
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  }
}


(Opcional) Husky pre-commit rodando eslint + tsc --noEmit.

PARTE 3 — Verificações de fluxo (do seu repo novo)

Ingestão (chat/links/arquivos) → cai na curadoria (HITL), antes da KB. ✅

Curadoria → fila, análise automática por curator-agent, promoção. ✅

Promoção → indexa no RAG (knowledge-indexer + vector-store). ✅ (Agora com persistência/snapshot do patch)

Namespaces/multi-agentes → coerente com docs; usado no admin. ✅

Fallback automático → priority-orchestrator + free-llm-providers; padronizado com OPENROUTER_API_KEY no patch. ✅

Política UNRESTRICTED por padrão → ativo via pipeline. ✅

Métricas → tokens/latência/custo expostos; trate provedores “free” como custo 0 para consistência. ✅

PARTE 4 — Refino de performance & limpeza

server/routes.ts (4801 linhas):

Mover handlers residuais para server/routes/* por domínio;

Substituir console.* por logger;

Remover TODO duplicado;

Zod para todas rotas com JSON;

Tipar catch e reduzir any progressivamente.

RAG:

Normalizar vetores (unit norm) na criação (cosseno vira dot-product).

Filtro por namespace por padrão; logar faltas em debug.

GPU:

Com breaker ativo, agendar health-check e remoção temporária de nós “quebrados”.

PARTE 5 — Checklist de produção (executável)

 check-env.ts ativado no boot.

 helmet + cors aplicados.

 Logger com requestId, troca de console.*.

 ENV padronizada: OPENROUTER_API_KEY (+ alias mantido).

 vector-store com load()/save() + snapshot on ingest/SIGTERM.

 Rebuild incremental via fila do knowledge-indexer.

 SSE no chat (endpoint + front).

 Audit trail exposto e aba no admin.

 Docker rodando USER app.

 ESLint + (opcional) Husky.